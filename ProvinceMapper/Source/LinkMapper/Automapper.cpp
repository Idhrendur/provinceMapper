#include "Automapper.h"

#include "Log.h"
#include "Provinces/Province.h"

void Automapper::registerMatch(const std::shared_ptr<Province>& srcProvince, const std::shared_ptr<Province>& targetProvince)
{
	const auto& srcProvinceID = srcProvince->ID;
	const auto& targetProvinceID = targetProvince->ID;

	if (sourceProvinceShares.contains(srcProvinceID))
	{
		if (sourceProvinceShares[srcProvinceID].contains(targetProvinceID))
		{
			sourceProvinceShares[srcProvinceID][targetProvinceID]++;
		}
		else
		{
			sourceProvinceShares[srcProvinceID][targetProvinceID] = 1;
		}
	}
	else
	{
		sourceProvinceShares[srcProvinceID][targetProvinceID] = 1;

		// When registering a new source province, update the cache of impassable source provinces.
		if (srcProvince->isImpassable())
		{
			srcImpassablesCache.insert(srcProvinceID);
		}
	}

	if (targetProvinceShares.contains(targetProvinceID))
	{
		if (targetProvinceShares[targetProvinceID].contains(srcProvinceID))
		{
			targetProvinceShares[targetProvinceID][srcProvinceID]++;
		}
		else
		{
			targetProvinceShares[targetProvinceID][srcProvinceID] = 1;
		}
	}
	else
	{
		targetProvinceShares[targetProvinceID][srcProvinceID] = 1;

		// When registering a new target province, update the cache of impassable target provinces.
		if (targetProvince->isImpassable())
		{
			tgtImpassablesCache.insert(targetProvinceID);
		}
	}
}

std::map<int, std::string, std::greater<>> getHighestMatches(const std::map<std::string, int>& shares)
{
	// Flip the shares map to get the shares as keys, with descending order.
	std::map<int, std::string, std::greater<>> sharesMap;
	for (const auto& [provID, share]: shares)
	{
		sharesMap[share] = provID;
	}

	return sharesMap;
}

bool Automapper::isSourceProvinceAvailable(const std::string& srcProvID)
{
	if (unavailableSources.contains(srcProvID))
	{
		return false;
	}

	const auto& link = activeVersion->getLinkForSourceProvince(srcProvID);
	if (!link)
	{
		return true;
	}

	if (link->getTargets().size() == 1)
	{
		return true;
	}
	unavailableSources.insert(srcProvID);
	return false;
}

bool Automapper::isTargetProvinceAvailable(const std::string& tgtProvID)
{
	if (unavailableTargets.contains(tgtProvID))
	{
		return false;
	}

	const auto& link = activeVersion->getLinkForTargetProvince(tgtProvID);
	if (!link)
	{
		return true;
	}

	if (link->getSources().size() == 1)
	{
		return true;
	}
	unavailableTargets.insert(tgtProvID);
	return false;
}

void Automapper::mapProvinces(const std::string& srcProvID, const std::string& tgtProvID)
{
	activeVersion->addAutogeneratedLink(srcProvID, tgtProvID);

	// Log(LogLevel::Debug) << "Cleaning after mapping " << srcProvID << " to " << tgtProvID; // TODO: remove this
	sourceProvinceShares[srcProvID].erase(tgtProvID);
	targetProvinceShares[tgtProvID].erase(srcProvID);
	// LOG(LogLevel::Debug) << "                         Cleaned after mapping " << srcProvID << " to " << tgtProvID; // TODO: remove this

	alreadyMappedSrcProvincesCache.insert(srcProvID);
	alreadyMappedTgtProvincesCache.insert(tgtProvID);
}

void Automapper::cleanUpSourceProvinceShares()
{
	for (const auto& key: srcProvincesToRemove)
	{
		sourceProvinceShares.erase(key);
	}
}

void Automapper::cleanUpTargetProvinceShares()
{
	for (const auto& key: tgtProvincesToRemove)
	{
		targetProvinceShares.erase(key);
	}
}

void Automapper::generateLinks()
{
	// General rules for the automapping:
	// - We don't modify the hand-made links.
	// - Provinces belonging to hand-made links are excluded from the automapping.
	// - We don't create many-to-many mappings.
	// - A source province is considered available for further mapping if it's not mapped to multiple target provinces.
	// - A target province is considered available for further mapping if it's not mapped to multiple source provinces.

	activeVersion->deactivateLink();

	// 1. For all non-impassable target provinces:
	//	   If the most matching source province is available and not impassable, map them.
	Log(LogLevel::Debug) << "\nLink generation step 1...";
	for (const auto& [tgtProvID, srcProvMatches]: targetProvinceShares)
	{
		if (tgtImpassablesCache.contains(tgtProvID))
		{
			continue;
		}

		auto highestSrcMatches = getHighestMatches(srcProvMatches);

		const auto& srcProvID = highestSrcMatches.begin()->second;
		if (srcImpassablesCache.contains(srcProvID))
		{
			continue;
		}
		if (alreadyMappedSrcProvincesCache.contains(srcProvID))
		{ // Avoid many-to-many mappings.
			continue;
		}
		if (!isSourceProvinceAvailable(srcProvID))
		{
			continue;
		}

		mapProvinces(srcProvID, tgtProvID);
		if (tgtProvID == "1441" || tgtProvID == "9601") // TODO: remove this
		{
			Log(LogLevel::Debug) << "TARGET PROV " << tgtProvID << " mapped to " << srcProvID << " in step 1.";
		}

		// tgtProvID can be removed from targetProvinceShares because it's already mapped.
		// Schedule it for removal after the loop to avoid iterator invalidation.
		tgtProvincesToRemove.insert(tgtProvID);
	}
	cleanUpTargetProvinceShares();

	// 2. For all yet unmapped non-impassable source provinces:
	//	   If the most matching target province is available and not impassable, map them.
	Log(LogLevel::Debug) << "\nLink generation step 2...";
	for (const auto& [srcProvID, tgtProvMatches]: sourceProvinceShares)
	{
		if (srcImpassablesCache.contains(srcProvID))
		{
			continue;
		}
		if (tgtProvMatches.empty())
		{
			continue;
		}

		auto highestTgtMatches = getHighestMatches(tgtProvMatches);

		const auto& tgtProvID = highestTgtMatches.begin()->second;
		if (tgtImpassablesCache.contains(tgtProvID))
		{
			continue;
		}
		if (alreadyMappedSrcProvincesCache.contains(srcProvID) && alreadyMappedTgtProvincesCache.contains(tgtProvID))
		{
			continue;
		}
		if (!isTargetProvinceAvailable(tgtProvID))
		{
			continue;
		}

		mapProvinces(srcProvID, tgtProvID);
		if (tgtProvID == "1441" || tgtProvID == "9601") // TODO: remove this
		{
			Log(LogLevel::Debug) << "TARGET PROV " << tgtProvID << " mapped to " << srcProvID << " in step 2.";
		}

		srcProvincesToRemove.insert(srcProvID);
	}
	cleanUpSourceProvinceShares();

	// 3. For all yet unmapped non-impassable target provinces:
	//	   Try to use the most matching available non-impassable source province to map them.
	Log(LogLevel::Debug) << "\nLink generation step 3...";
	for (const auto& [tgtProvID, srcProvMatches]: targetProvinceShares)
	{
		if (tgtImpassablesCache.contains(tgtProvID))
		{
			continue;
		}
		if (srcProvMatches.empty())
		{
			continue;
		}

		auto highestSrcMatches = getHighestMatches(srcProvMatches);
		for (const auto& [share, srcProvID]: highestSrcMatches)
		{
			if (srcImpassablesCache.contains(srcProvID))
			{
				continue;
			}
			if (alreadyMappedSrcProvincesCache.contains(srcProvID) && alreadyMappedTgtProvincesCache.contains(tgtProvID))
			{
				continue;
			}
			if (!isSourceProvinceAvailable(srcProvID))
			{
				continue;
			}

			mapProvinces(srcProvID, tgtProvID);
			if (tgtProvID == "1441" || tgtProvID == "9601") // TODO: remove this
			{
				Log(LogLevel::Debug) << "TARGET PROV " << tgtProvID << " mapped to " << srcProvID << " in step 3.";
			}

			tgtProvincesToRemove.insert(tgtProvID);
			break;
		}
	}
	cleanUpTargetProvinceShares();

	// 4. For all yet unmapped non-impassable source provinces:target
	//	   Try to use the most matching available non-impassable target province to map them.
	Log(LogLevel::Debug) << "\nLink generation step 4...";
	for (const auto& [srcProvID, tgtProvMatches]: sourceProvinceShares)
	{
		if (srcImpassablesCache.contains(srcProvID))
		{
			continue;
		}
		if (tgtProvMatches.empty())
		{
			continue;
		}

		auto highestTgtMatches = getHighestMatches(tgtProvMatches);
		for (const auto& [share, tgtProvID]: highestTgtMatches)
		{
			if (tgtImpassablesCache.contains(tgtProvID))
			{
				continue;
			}
			if (alreadyMappedSrcProvincesCache.contains(srcProvID) && alreadyMappedTgtProvincesCache.contains(tgtProvID))
			{
				continue;
			}
			if (!isTargetProvinceAvailable(tgtProvID))
			{
				continue;
			}

			mapProvinces(srcProvID, tgtProvID);
			if (tgtProvID == "1441" || tgtProvID == "9601") // TODO: remove this
			{
				Log(LogLevel::Debug) << "TARGET PROV " << tgtProvID << " mapped to " << srcProvID << " in step 4.";
			}

			srcProvincesToRemove.insert(srcProvID);
			break;
		}
	}
	cleanUpSourceProvinceShares();

	// 5. For all yet unmapped target provinces:
	//    Try to use the most matching available source province to map them.
	Log(LogLevel::Debug) << "\nLink generation step 5...";
	for (const auto& [tgtProvID, srcProvMatches]: targetProvinceShares)
	{
		auto highestSrcMatches = getHighestMatches(srcProvMatches);
		for (const auto& [share, srcProvID]: highestSrcMatches)
		{
			if (alreadyMappedSrcProvincesCache.contains(srcProvID) && alreadyMappedTgtProvincesCache.contains(tgtProvID))
			{
				continue;
			}
			if (!isSourceProvinceAvailable(srcProvID))
			{
				continue;
			}

			mapProvinces(srcProvID, tgtProvID);
			if (tgtProvID == "1441" || tgtProvID == "9601") // TODO: remove this
			{
				Log(LogLevel::Debug) << "TARGET PROV " << tgtProvID << " mapped to " << srcProvID << " in step 5.";
			}

			tgtProvincesToRemove.insert(tgtProvID);
			break;
		}
	}
	cleanUpTargetProvinceShares();

	// 6. For all yet unmapped source provinces:
	//    Try to use the most matching available target province to map them.
	Log(LogLevel::Debug) << "\nLink generation step 6...";
	for (const auto& [srcProvID, tgtProvMatches]: sourceProvinceShares)
	{
		auto highestTgtMatches = getHighestMatches(tgtProvMatches);
		for (const auto& [share, tgtProvID]: highestTgtMatches)
		{
			if (alreadyMappedSrcProvincesCache.contains(srcProvID) && alreadyMappedTgtProvincesCache.contains(tgtProvID))
			{
				continue;
			}
			if (!isTargetProvinceAvailable(tgtProvID))
			{
				continue;
			}

			mapProvinces(srcProvID, tgtProvID);
			if (tgtProvID == "1441" || tgtProvID == "9601") // TODO: remove this
			{
				Log(LogLevel::Debug) << "TARGET PROV " << tgtProvID << " mapped to " << srcProvID << " in step 6.";
			}

			srcProvincesToRemove.insert(srcProvID);
			break;
		}
	}
	cleanUpSourceProvinceShares();

	Log(LogLevel::Info) << "<> Automapping complete.";
}
